# MetaQuant

MetaQuant is a modular, language-agnostic quantitative research and stock screening framework. It centralizes market data in DuckDB, executes external models via a JSON process contract, and provides a minimal backtesting and evaluation toolkit to compare ideas across contributors.

## Architecture Overview
- **Core (Python 3.11+)**: configuration, DuckDB data access, model registry, subprocess model runner, backtest engine, portfolio accounting, and evaluation utilities.
- **DuckDB-first storage**: backtests query market data from a shared read-only DuckDB database and write results to model-specific databases. This read/write separation enables parallel execution without database locking conflicts. ETL helpers normalize data from SQL Server, Oracle, Postgres, or CSV/Parquet into the shared schema.
- **Language-agnostic models**: each model ships with a `model.json` manifest describing the entrypoint command. Models read JSON from stdin and emit JSON to stdout, so they can be written in any language.
- **Experiments via config**: YAML files describe universes, time windows, models to run, and evaluation metrics.
- **Runtime-aware execution**: manifests declare runtime (host or docker) and platform (linux/amd64, windows/amd64, or any) and are scheduled onto compatible nodes.

## Repository Layout
```
pyproject.toml
config/                # base + logging config
core/
  config.py            # app config loader
  data_access/         # DuckDB adapter + ETL stubs
  registry/            # manifest schema + discovery
  models/              # JSON contracts + runner
  backtest/            # engine + portfolio logic
  evaluation/          # metrics and reporting
  cli.py               # Typer-based CLI
models/
  alice/sector_momentum_v1/    # example Python model
  bob/options_vol_spread_v1/   # example Go placeholder
scripts/              # schema init + ingestion helpers
experiments/          # sample experiment config
```

## DuckDB Schema

MetaQuant uses a read/write separation pattern to enable parallel model execution:

### Common Market Data Database (`data/metaquant.duckdb`)
Run `quantfw init-db` (or execute `scripts/init_duckdb_schema.py`) to create the shared market data database. This database is opened in **read-only mode** during backtests and contains:
- `securities`: master instrument info (equities and options)
- `daily_prices`: OHLCV by security/date
- `options_quotes`: greeks/IV per option/date
- `fundamentals`: metric values per report date
- `market_features`: market/regime descriptors

### Model-Specific Results Databases (`data/<model_id>.duckdb`)
Each backtest run automatically creates a model_id results database containing:
- `model_runs`: run metadata, parameters, and timestamps
- `model_signals`: trading signals generated by the model
- `trades`: executed trades from the backtest
- `model_metrics`: performance metrics (Sharpe, drawdown, etc.)

This design avoids DuckDB write contention (DuckDB allows only one writer at a time), enabling multiple models to run in parallel without database locking conflicts.

## Model Contract
Models are external executables. Manifest (`model.json`) fields include `model_id`, `version`, `entrypoint`, `input_types`, and `output_type`. The runner launches `entrypoint` in the model directory, writes JSON payload to stdin, and expects JSON output:

**Input skeleton**
```json
{
  "mode": "backtest",
  "model_id": "sector_momentum_v1",
  "run_id": "<uuid>",
  "universe": [{"security_id": 101, "ticker": "AAPL"}],
  "data": {"prices": [...]},
  "parameters": {"lookback_days": 30},
  "time_range": {"start": "2020-01-01", "end": "2020-12-31"}
}
```

**Output skeleton**
```json
{
  "model_id": "sector_momentum_v1",
  "run_id": "<uuid>",
  "signals": [
    {"timestamp": "2020-01-02", "security_id": 101, "signal_type": "long", "strength": 1.0, "confidence": 0.8, "meta": {}}
  ]
}
```

### Runtime, platform, and nodes
- Every manifest declares a `runtime` (`host` or `docker`) and a `platform` (`linux/amd64`, `windows/amd64`, or `any`).
- Docker models add `docker_image` and `docker_entrypoint`; host models keep `entrypoint` and optional `dependencies` (e.g., `requirements_file`).
- Execution nodes are listed in `config/base.yaml` with their supported runtimes and platform. The backtest CLI can pick a node automatically or you can pass `--node` or `--node-tags` to direct scheduling.

## CLI Usage
- `quantfw list-models` — discover manifests under `models/`.
- `quantfw init-db --config config/base.yaml` — create the shared market data DuckDB schema at the configured path.
- `quantfw backtest` — run a backtest. Results are written to `data/<model_id>.duckdb`.

### Backtest Examples

```bash
# Using security IDs (integers)
quantfw backtest --model-id sector_momentum_v1 --security-ids 1,2,3 \
  --start-date 2020-01-01 --end-date 2020-12-31 --params '{"lookback_days":30}'

# Using ticker symbols
quantfw backtest --model-id sector_momentum_v1 --tickers AAPL,MSFT,GOOGL \
  --start-date 2020-01-01 --end-date 2020-12-31 --params '{"lookback_days":30}'

# Using a tickers file (one ticker per line)
quantfw backtest --model-id sector_momentum_v1 --tickers-file my_universe.txt \
  --start-date 2020-01-01 --end-date 2020-12-31 --params '{"lookback_days":30}'
```

**Note**: Specify exactly one of `--security-ids`, `--tickers`, or `--tickers-file`. Tickers are automatically resolved to security IDs by looking up the `securities` table.

**Parallel Execution**: Multiple backtest commands can run in parallel without conflicts. Each run reads from the shared market data database (read-only) and writes to its own results database.

## Adding a New Model
1. Create a directory under `models/<author>/<model_name>/`.
2. Add `model.json` with metadata and the `entrypoint` command.
3. Implement the executable to read the JSON input from stdin and write JSON output to stdout.
4. The manifest is discovered automatically; no core code changes are required.

## Experiments
YAML files in `experiments/` can define universes, date ranges, models, and metrics. They can be referenced by orchestration tooling or passed directly to CLI commands.

## Contributing
- Install dependencies with [uv](https://docs.astral.sh/uv/): `uv venv .venv` then `source .venv/bin/activate` and `uv pip install -e .`.
- Run unit tests with `uv run pytest` (stubs provided for expansion).
- Extend ETL modules to connect to your data sources and populate DuckDB before running backtests.
